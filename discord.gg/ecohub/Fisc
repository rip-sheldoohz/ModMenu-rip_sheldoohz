if getgenv().ecohub then warn("[EcoHub] : Already executed!") return end
getgenv().ecohub = true

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "EcoHub - Premium | Fisch",
    SubTitle = "discord.gg/ecohub - By rip_sheldoohz",
    TabWidth = 160,
    Size = UDim2.fromOffset(550, 350),
    Acrylic = false,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

-- Este script funciona apenas em PCs
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- Fun√ß√£o para detectar dispositivo
local function IsUsingMobile()
    -- Detecta toque (mobile)
    if UserInputService:GetLastInputType() == Enum.UserInputType.Touch then
        return true
    end
    -- Detecta controle (console)
    if #UserInputService:GetConnectedGamepads() > 0 then
        return true
    end
    return false
end

-- Verifica√ß√£o e a√ß√£o
if IsUsingMobile() then
    player:Kick("Acesso negado.\n\nEste script √© exclusivo para computadores.\nDispositivos m√≥veis e consoles n√£o s√£o compat√≠veis com esta execu√ß√£o.\n\nPor favor, entre novamente usando um PC para continuar.")
    return
end

local Tabs = {
    Inicio = Window:AddTab({ Title = "In√≠cio", Icon = "home" }),
    Farm = Window:AddTab({ Title = "Farm", Icon = "leaf" }),
    Usuario = Window:AddTab({ Title = "Local Player", Icon = "user" }),
    Vision = Window:AddTab({ Title = "Vis√£o", Icon = "eye" }),
    Lojinha = Window:AddTab({ Title = "Store", Icon = "shopping-cart" }),
    Status = Window:AddTab({ Title = "Status", Icon = "clock" }),  
    Teleporte = Window:AddTab({ Title = "Teleportes", Icon = "navigation" }),
    Settings = Window:AddTab({ Title = "Configura√ß√µes", Icon = "settings" })
}

--Settings
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Vari√°veis de controle
local WalkZone = "Ocean"
local connections = {
    dayOnly = nil,
    bypassGps = nil,
    instantInteract = nil
}

local function GetHumanoidRootPart()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return LocalPlayer.Character.HumanoidRootPart
    end
    return nil
end

local function ExportValue(num, decimals)
    decimals = decimals or 1
    return tonumber(string.format("%." .. decimals .. "f", num))
end

local function GetPosition()
    local hrp = GetHumanoidRootPart()
    if not hrp then
        return {0, 0, 0}
    end
    return {hrp.Position.X, hrp.Position.Y, hrp.Position.Z}
end

-- Event de Character Added
LocalPlayer.CharacterAdded:Connect(function(char)
    LocalCharacter = char
    task.wait(0.5)
    
    pcall(function()
        local humanoid = char:WaitForChild("Humanoid")
        
        if Options and Options.WalkSpeed and Options.WalkSpeed.Value ~= 16 then
            humanoid.WalkSpeed = Options.WalkSpeed.Value
        end
        
        if Options and Options.JumpPower and Options.JumpPower.Value ~= 50 then
            humanoid.JumpPower = Options.JumpPower.Value
        end
    end)
end)

-- ===== SE√á√ÉO MAR =====
Tabs.Settings:AddSection("Mar")

Tabs.Settings:AddToggle("WalkOnWater", {
    Title = "Andar na √Ågua",
    Description = "Permite andar sobre a √°gua",
    Default = false,
    Callback = function(value)
        task.spawn(function()
            pcall(function()
                local zones = Workspace:FindFirstChild("zones")
                if not zones then return end
                
                local fishing = zones:FindFirstChild("fishing")
                if not fishing then return end
                
                for _, v in pairs(fishing:GetChildren()) do
                    if v and v:IsA("BasePart") and v.Name == WalkZone then
                        v.CanCollide = value
                        
                        -- Se for Ocean, tamb√©m ativa Deep Ocean
                        if v.Name == "Ocean" then
                            local deepOcean = fishing:FindFirstChild("Deep Ocean")
                            if deepOcean and deepOcean:IsA("BasePart") then
                                deepOcean.CanCollide = value
                            end
                        end
                    end
                end
            end)
        end)
    end
})

Tabs.Settings:AddDropdown("WalkZoneDropdown", {
    Title = "Zona de √Ågua",
    Description = "Selecione a zona para andar",
    Values = {"Ocean", "Desolate Deep", "The Depths"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        if value and value ~= "" then
            WalkZone = tostring(value)
        end
    end
})

-- ===== SE√á√ÉO OTIMIZA√á√ÉO =====
Tabs.Settings:AddSection("Otimiza√ß√£o")

Tabs.Settings:AddButton({
    Title = "Remover Sombras",
    Description = "Remove todas as sombras e reflexos do jogo",
    Callback = function()
        task.spawn(function()
            pcall(function()
                -- Remove sombras das partes
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj and obj:IsA("BasePart") then
                        obj.CastShadow = false
                    end
                end

                -- Configura√ß√µes de ilumina√ß√£o
                Lighting.GlobalShadows = false
                Lighting.Brightness = 0
                Lighting.EnvironmentDiffuseScale = 0
                Lighting.EnvironmentSpecularScale = 0
                Lighting.ShadowSoftness = 0
                Lighting.Ambient = Color3.new(1, 1, 1)
                Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
                Lighting.FogEnd = 9e9
                Lighting.FogStart = 9e9
                Lighting.FogColor = Color3.new(1, 1, 1)
                Lighting.ExposureCompensation = 0

                -- Remove efeitos visuais
                for _, v in ipairs(Lighting:GetChildren()) do
                    if v and (v:IsA("PostEffect") or v:IsA("Atmosphere") or v:IsA("BloomEffect") or v:IsA("ColorCorrectionEffect")) then
                        v:Destroy()
                    end
                end

                -- Otimiza √°gua
                local Terrain = Workspace:FindFirstChildOfClass("Terrain")
                if Terrain then
                    Terrain.WaterReflectance = 0
                    Terrain.WaterTransparency = 1
                    Terrain.WaterWaveSize = 0
                    Terrain.WaterWaveSpeed = 0
                end
                
                Fluent:Notify({
                    Title = "Sombras Removidas",
                    Content = "Otimiza√ß√£o aplicada",
                    Duration = 2
                })
            end)
        end)
    end
})

Tabs.Settings:AddButton({
    Title = "Otimizar Materiais",
    Description = "Remove detalhes e otimiza materiais",
    Callback = function()
        task.spawn(function()
            pcall(function()
                -- Otimiza materiais
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj and obj:IsA("BasePart") then
                        obj.Material = Enum.Material.SmoothPlastic
                        obj.Reflectance = 0
                        obj.CastShadow = false
                    elseif obj and (obj:IsA("Decal") or obj:IsA("Texture")) then
                        obj:Destroy()
                    end
                end

                -- Ilumina√ß√£o
                Lighting.GlobalShadows = false
                Lighting.EnvironmentSpecularScale = 0
                Lighting.EnvironmentDiffuseScale = 0
                Lighting.ShadowSoftness = 0
                Lighting.Brightness = 1
                Lighting.Ambient = Color3.new(1, 1, 1)
                Lighting.OutdoorAmbient = Color3.new(1, 1, 1)

                -- Remove efeitos
                for _, v in ipairs(Lighting:GetChildren()) do
                    if v and (v:IsA("PostEffect") or v:IsA("Atmosphere") or v:IsA("BloomEffect") or 
                             v:IsA("ColorCorrectionEffect") or v:IsA("DepthOfFieldEffect")) then
                        v:Destroy()
                    end
                end

                -- Otimiza √°gua
                local Terrain = Workspace:FindFirstChildOfClass("Terrain")
                if Terrain then
                    Terrain.WaterReflectance = 0
                    Terrain.WaterTransparency = 1
                    Terrain.WaterWaveSize = 0
                    Terrain.WaterWaveSpeed = 0
                end
                
                Fluent:Notify({
                    Title = "Materiais Otimizados",
                    Content = "Desempenho melhorado",
                    Duration = 2
                })
            end)
        end)
    end
})

-- ===== SE√á√ÉO PEIXES =====
Tabs.Settings:AddSection("Peixes")

Tabs.Settings:AddToggle("FishRadarToggle", {
    Title = "Radar de Peixe",
    Description = "Mostra localiza√ß√£o dos peixes",
    Default = false,
    Callback = function(value)
        task.spawn(function()
            pcall(function()
                for _, v in pairs(CollectionService:GetTagged("radarTag")) do
                    if v and (v:IsA("BillboardGui") or v:IsA("SurfaceGui")) then
                        v.Enabled = value
                    end
                end
            end)
        end)
    end
})

Tabs.Settings:AddToggle("GPSToggle", {
    Title = "GPS Coordenadas",
    Description = "Mostra suas coordenadas na tela",
    Default = false,
    Callback = function(value)
        task.spawn(function()
            pcall(function()
                if value then
                    -- Verifica se GPS j√° existe
                    local gpsExists = PlayerGui:FindFirstChild("hud") and 
                                     PlayerGui.hud:FindFirstChild("safezone") and 
                                     PlayerGui.hud.safezone:FindFirstChild("backpack") and 
                                     PlayerGui.hud.safezone.backpack:FindFirstChild("xyz")
                    
                    if not gpsExists then
                        -- Busca GPS nos recursos
                        local gpsResource = ReplicatedStorage:FindFirstChild("resources")
                        if gpsResource then
                            local items = gpsResource:FindFirstChild("items")
                            if items then
                                local itemsFolder = items:FindFirstChild("items")
                                if itemsFolder then
                                    local GPS = itemsFolder:FindFirstChild("GPS")
                                    if GPS then
                                        local gpsItem = GPS:FindFirstChild("GPS")
                                        if gpsItem then
                                            local gpsMain = gpsItem:FindFirstChild("gpsMain")
                                            if gpsMain then
                                                local xyz = gpsMain:FindFirstChild("xyz")
                                                if xyz then
                                                    -- Clona GPS
                                                    local gpsClone = xyz:Clone()
                                                    gpsClone.Parent = PlayerGui.hud.safezone.backpack
                                                    
                                                    -- Desconecta conex√£o antiga
                                                    if connections.bypassGps then
                                                        connections.bypassGps:Disconnect()
                                                    end
                                                    
                                                    -- Atualiza coordenadas
                                                    connections.bypassGps = RunService.Heartbeat:Connect(function()
                                                        if not gpsClone or not gpsClone.Parent then
                                                            if connections.bypassGps then
                                                                connections.bypassGps:Disconnect()
                                                                connections.bypassGps = nil
                                                            end
                                                            return
                                                        end
                                                        
                                                        local pos = GetPosition()
                                                        local str = string.format("%s, %s, %s", 
                                                            ExportValue(pos[1]), 
                                                            ExportValue(pos[2]), 
                                                            ExportValue(pos[3])
                                                        )
                                                        gpsClone.Text = "<font color='#ff4949'>X</font><font color='#a3ff81'>Y</font><font color='#626aff'>Z</font>: " .. str
                                                    end)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                    -- Remove GPS
                    if PlayerGui and PlayerGui:FindFirstChild("hud") then
                        local hud = PlayerGui.hud
                        if hud:FindFirstChild("safezone") then
                            local safezone = hud.safezone
                            if safezone:FindFirstChild("backpack") then
                                local xyz = safezone.backpack:FindFirstChild("xyz")
                                if xyz then
                                    xyz:Destroy()
                                end
                            end
                        end
                    end
                    
                    if connections.bypassGps then
                        connections.bypassGps:Disconnect()
                        connections.bypassGps = nil
                    end
                end
            end)
        end)
    end
})

-- ===== SE√á√ÉO MODO DE JOGO =====
Tabs.Settings:AddSection("Modo de Jogo")

Tabs.Settings:AddToggle("RemoveFogToggle", {
    Title = "Remover Neblina",
    Description = "Remove a neblina do ambiente",
    Default = false,
    Callback = function(value)
        task.spawn(function()
            pcall(function()
                if value then
                    local sky = Lighting:FindFirstChild("Sky")
                    if sky then
                        local bloom = Lighting:FindFirstChild("bloom")
                        if bloom then
                            sky.Parent = bloom
                        end
                    end
                else
                    local bloom = Lighting:FindFirstChild("bloom")
                    if bloom then
                        local sky = bloom:FindFirstChild("Sky")
                        if sky then
                            sky.Parent = Lighting
                        end
                    end
                end
            end)
        end)
    end
})

Tabs.Settings:AddToggle("AlwaysDayToggle", {
    Title = "Sempre Dia",
    Description = "Mant√©m o jogo sempre de dia",
    Default = false,
    Callback = function(value)
        if connections.dayOnly then
            connections.dayOnly:Disconnect()
            connections.dayOnly = nil
        end
        
        if value then
            connections.dayOnly = RunService.Heartbeat:Connect(function()
                pcall(function()
                    Lighting.TimeOfDay = "12:00:00"
                end)
            end)
        end
    end
})

Tabs.Settings:AddToggle("InstantInteractToggle", {
    Title = "Intera√ß√£o Instant√¢nea",
    Description = "Remove o tempo de espera para interagir",
    Default = false,
    Callback = function(value)
        if connections.instantInteract then
            connections.instantInteract:Disconnect()
            connections.instantInteract = nil
        end
        
        if value then
            task.spawn(function()
                pcall(function()
                    -- Aplica em prompts existentes
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if v and v:IsA("ProximityPrompt") then
                            v.HoldDuration = 0
                        end
                    end
                    
                    -- Aplica em novos prompts
                    connections.instantInteract = Workspace.DescendantAdded:Connect(function(descendant)
                        if descendant and descendant:IsA("ProximityPrompt") then
                            descendant.HoldDuration = 0
                        end
                    end)
                end)
            end)
        end
    end
})

-- Limpeza ao sair
game.Players.LocalPlayer.AncestryChanged:Connect(function()
    for k, v in pairs(connections) do
        if v and type(v) == "userdata" then
            pcall(function()
                v:Disconnect()
            end)
        end
        connections[k] = nil
    end
end)

--Procurar
Tabs.Inicio:AddSection("Procurar Servidor")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera

local player = Players.LocalPlayer
local placeId = game.PlaceId

local jobIdInput = ""
Tabs.Inicio:AddInput("JobIdInput", {
    Title = "Job ID do Servidor",
    Description = "Cole o Job ID aqui",
    Default = "",
    Placeholder = "Cole o Job ID",
    Numeric = false,
    Finished = false,
    Callback = function(value)
        jobIdInput = value
    end
})

Tabs.Inicio:AddButton({
    Title = "Conectar ao Servidor",
    Description = "Conecta ao servidor usando o Job ID",
    Callback = function()
        if jobIdInput == "" then return end
        pcall(function()
            TeleportService:TeleportToPlaceInstance(placeId, jobIdInput, player)
        end)
    end
})

Tabs.Inicio:AddButton({
    Title = "Copiar Job ID Atual",
    Description = "Copia o Job ID do servidor atual",
    Callback = function()
        if setclipboard then
            setclipboard(game.JobId)
        end
    end
})

Tabs.Inicio:AddSection("Outros")

Tabs.Inicio:AddButton({
    Title = "Server Hop",
    Description = "Procura servidor com pouca gente",
    Callback = function()
        task.spawn(function()
            local success, err = pcall(function()
                local servers = {}
                local cursor = ""
                repeat
                    local url = string.format(
                        "https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100&cursor=%s",
                        placeId, cursor
                    )
                    local data = HttpService:JSONDecode(game:HttpGet(url))
                    if data and data.data then
                        for _, s in pairs(data.data) do
                            if s.playing < s.maxPlayers and s.id ~= game.JobId then
                                table.insert(servers, s)
                            end
                        end
                    end
                    cursor = data.nextPageCursor or ""
                until cursor == ""
                if #servers > 0 then
                    table.sort(servers, function(a, b)
                        return a.playing < b.playing
                    end)
                    TeleportService:TeleportToPlaceInstance(placeId, servers[1].id, player)
                end
            end)
            if not success then warn(err) end
        end)
    end
})

Tabs.Inicio:AddButton({
    Title = "Rejoin",
    Description = "Sair e entrar no mesmo servidor",
    Callback = function()
        pcall(function()
            TeleportService:TeleportToPlaceInstance(placeId, game.JobId, player)
        end)
    end
})

Tabs.Inicio:AddButton({
    Title = "Servidor Cheio",
    Description = "Procura servidor quase cheio",
    Callback = function()
        task.spawn(function()
            local success, err = pcall(function()
                local servers = {}
                local cursor = ""
                repeat
                    local url = string.format(
                        "https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&cursor=%s",
                        placeId, cursor
                    )
                    local data = HttpService:JSONDecode(game:HttpGet(url))
                    if data and data.data then
                        for _, s in pairs(data.data) do
                            if s.playing < s.maxPlayers and s.id ~= game.JobId then
                                table.insert(servers, s)
                            end
                        end
                    end
                    cursor = data.nextPageCursor or ""
                until cursor == ""
                if #servers > 0 then
                    table.sort(servers, function(a, b)
                        return a.playing > b.playing
                    end)
                    TeleportService:TeleportToPlaceInstance(placeId, servers[1].id, player)
                end
            end)
            if not success then warn(err) end
        end)
    end
})

local function updateCamera()
    if Camera then
        Camera.CFrame = Camera.CFrame + Camera.CFrame:VectorToWorldSpace(Vector3.new(0, 0, 1.3))
    end
end

local function toggleState()
    isActive = not isActive
    debounce = false
end

local function onInputBegan(input)
    if input.KeyCode == activationKey and not debounce then
        debounce = true
        toggleState()
    end
end

RunService.RenderStepped:Connect(function(dt)
    -- O c√≥digo de FOV foi removido
end)

UserInputService.InputBegan:Connect(onInputBegan)

local function obfuscateName()
    local chars = {"Game", "Ui", "System", "Tool", "Helper", "Manager", "Handler", "Controller"}
    local nums = tostring(math.random(1000, 9999))
    return chars[math.random(#chars)] .. nums
end

local guiName = obfuscateName()
local mainFrameName = obfuscateName()
local scriptName = obfuscateName()

local function safeGetService(serviceName)
    local ok, service = pcall(function() return game:GetService(serviceName) end)
    return ok and service or nil
end

local Services = {
    Players = safeGetService("Players"),
    RunService = safeGetService("RunService"),
    ReplicatedStorage = safeGetService("ReplicatedStorage"),
    UserInputService = safeGetService("UserInputService")
}

if not Services.Players then return end

local player = Services.Players.LocalPlayer
if not player then
    Services.Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
    player = Services.Players.LocalPlayer
end

local isMobile = false
pcall(function()
    if Services.UserInputService and Services.UserInputService.TouchEnabled and not Services.UserInputService.KeyboardEnabled then
        isMobile = true
    end
end)

local BypassConfig = {
    Enabled = false,
    IsRunning = false,
    ObjectsRemoved = 0,
    Connections = {},
    LastCleanup = 0,
    CleanupInterval = isMobile and 180 or 60,
    MaxObjectsPerCleanup = isMobile and 3 or 10,
    MonitorInterval = isMobile and 120 or 45,
    ProcessDelay = isMobile and 0.3 or 0.1,
    ToggleInProgress = false
}

local detectionPatterns = {
    "anticheat", "anti_cheat", "anticheats",
    "ac_", "_ac", "detect", "detection",
    "monitor", "guard", "security",
    "scanner", "watcher", "tracker"
}

local protectedNames = {
    "FluentUI", "Fluent", "Library", "MainFrame", "Container", "EcoHub",
    guiName, mainFrameName, scriptName
}

local function isProtectedGui(obj)
    if not obj or not obj.Name then return false end
    local name = obj.Name
    for _, protected in ipairs(protectedNames) do
        if string.find(name, protected, 1, true) then
            return true
        end
    end
    return false
end

local function containsSuspicious(name)
    if not name or type(name) ~= "string" then return false end
    local lower = string.lower(name)
    for _, pattern in ipairs(detectionPatterns) do
        if string.find(lower, pattern, 1, true) then
            return true
        end
    end
    return false
end

local function safeDestroy(obj)
    if not obj or not obj.Parent or isProtectedGui(obj) then return false end
    
    local success = pcall(function()
        if obj:IsA("LocalScript") or obj:IsA("Script") or obj:IsA("ModuleScript") then
            obj.Disabled = true
        end
        obj.Parent = nil
        obj:Destroy()
    end)
    
    if success then
        BypassConfig.ObjectsRemoved = BypassConfig.ObjectsRemoved + 1
        return true
    end
    return false
end

local lastCleanupTime = 0

local function optimizedCleanup()
    local now = tick()
    if now - lastCleanupTime < BypassConfig.CleanupInterval then return end
    lastCleanupTime = now

    task.spawn(function()
        if not BypassConfig.Enabled or not BypassConfig.IsRunning then return end
        
        pcall(function()
            if player and player.PlayerGui then
                task.wait(BypassConfig.ProcessDelay)
                local guis = player.PlayerGui:GetChildren()
                for i = 1, math.min(#guis, BypassConfig.MaxObjectsPerCleanup) do
                    if not BypassConfig.Enabled or not BypassConfig.IsRunning then break end
                    local gui = guis[i]
                    if gui and containsSuspicious(gui.Name) and not isProtectedGui(gui) then
                        safeDestroy(gui)
                        if isMobile then
                            task.wait(BypassConfig.ProcessDelay)
                        end
                    end
                end
            end
        end)
    end)
end

local function hookProtection()
    if not hookmetamethod then return end
    
    pcall(function()
        local old
        old = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            if method == "Kick" and (self == player or self.Parent == player) then
                return nil
            end
            return old(self, ...)
        end)
    end)
end

local monitorConnection = nil

local function startMonitorLoop()
    if monitorConnection then return end
    
    monitorConnection = Services.RunService.Heartbeat:Connect(function()
        if not BypassConfig.Enabled or not BypassConfig.IsRunning then
            if monitorConnection then
                monitorConnection:Disconnect()
                monitorConnection = nil
            end
            return
        end
        
        optimizedCleanup()
    end)
end

local guiConnection = nil

local function startGuiMonitor()
    if guiConnection or not player or not player.PlayerGui then return end
    
    guiConnection = player.PlayerGui.ChildAdded:Connect(function(child)
        if not BypassConfig.Enabled or not BypassConfig.IsRunning then return end
        
        task.delay(0.7, function()
            if child and containsSuspicious(child.Name) and not isProtectedGui(child) then
                safeDestroy(child)
            end
        end)
    end)
end

local function startBypass()
    if BypassConfig.IsRunning or BypassConfig.ToggleInProgress then return end
    BypassConfig.ToggleInProgress = true
    
    BypassConfig.IsRunning = true
    BypassConfig.ObjectsRemoved = 0
    lastCleanupTime = 0
    
    print("[EcoHub] Iniciando bypass")
    
    task.spawn(function()
        task.wait(isMobile and 10 or 4)
        pcall(hookProtection)
        task.wait(BypassConfig.ProcessDelay)
        pcall(optimizedCleanup)
        task.wait(BypassConfig.ProcessDelay)
        pcall(startGuiMonitor)
        pcall(startMonitorLoop)
        print("[EcoHub] Bypass ativo")
        BypassConfig.ToggleInProgress = false
    end)
end

local function stopBypass()
    if BypassConfig.ToggleInProgress then return end
    BypassConfig.ToggleInProgress = true
    
    BypassConfig.IsRunning = false
    
    if monitorConnection then
        monitorConnection:Disconnect()
        monitorConnection = nil
    end
    
    if guiConnection then
        guiConnection:Disconnect()
        guiConnection = nil
    end
    
    for _, conn in ipairs(BypassConfig.Connections) do
        pcall(function() conn:Disconnect() end)
    end
    BypassConfig.Connections = {}
    
    print("[Maximus] Bypass desativado")
    BypassConfig.ToggleInProgress = false
end

if _G.EcoHubBypass then
    pcall(function() _G.EcoHubBypass.Stop() end)
end

_G.EcoHubBypass = {
    Start = startBypass,
    Stop = stopBypass,
    Config = BypassConfig
}

if Tabs and Tabs.Inicio then
    Tabs.Inicio:AddSection("Bypass")

    Tabs.Inicio:AddToggle("BypassToggle", {
        Title = "Ativar Bypass",
        Description = nil,
        Default = true,
        Callback = function(Value)
            if BypassConfig.ToggleInProgress then return end
            BypassConfig.Enabled = Value
            if Value then
                startBypass()
            else
                stopBypass()
            end
        end
    })
end

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local LocalizationService = game:GetService("LocalizationService")
local MarketplaceService = game:GetService("MarketplaceService")

-- Jogador
local player = Players.LocalPlayer
local startTime = tick()
local fps, ping, region = 0, 0, "Desconhecida"

-- Detectar executor
local function detectExecutor()
    local exec = "Desconhecido"
    if identifyexecutor then
        local s, r = pcall(identifyexecutor)
        if s and r then exec = r end
    elseif syn then
        exec = "Synapse X"
    elseif fluxus then
        exec = "Fluxus"
    elseif KRNL_LOADED then
        exec = "KRNL"
    elseif is_sirhurt_closure then
        exec = "SirHurt"
    elseif secure_load then
        exec = "Script-Ware"
    elseif Kavo then
        exec = "Kavo"
    elseif Wave then
        exec = "Wave"
    elseif getexecutorname then
        local s, name = pcall(getexecutorname)
        if s and name then exec = name end
    end
    return exec
end

local executor = detectExecutor()
local serverId = game.JobId or "N/A"
local placeName = "Carregando..."

pcall(function()
    placeName = MarketplaceService:GetProductInfo(game.PlaceId).Name
end)

pcall(function()
    region = LocalizationService.RobloxLocaleId or "Desconhecida"
end)

-- Abas Status
Tabs.Status:AddSection("üì° Informa√ß√µes do Servidor")
local servidorParagraph = Tabs.Status:AddParagraph({
    Title = "Servidor",
    Content = "Carregando..."
})

Tabs.Status:AddSection("üßç Informa√ß√µes do Jogador")
local jogadorParagraph = Tabs.Status:AddParagraph({
    Title = "Jogador",
    Content = "Carregando..."
})

-- Atualiza√ß√£o em loop
task.spawn(function()
    while task.wait(1) do
        -- FPS e Ping
        pcall(function()
            local deltaTime = RunService.RenderStepped:Wait()
            if deltaTime > 0 then
                fps = math.floor(1 / deltaTime)
            end

            local networkStats = Stats:FindFirstChild("Network")
            if networkStats then
                local pingStats = networkStats:FindFirstChild("ServerStatsItem")
                if pingStats then
                    local dataPing = pingStats:FindFirstChild("Data Ping")
                    if dataPing then
                        ping = math.floor(dataPing:GetValue())
                    end
                end
            end
        end)

        -- Uptime
        local uptime = math.floor(tick() - startTime)
        local hours = math.floor(uptime / 3600)
        local mins = math.floor((uptime % 3600) / 60)
        local secs = uptime % 60
        local playerCount = #Players:GetPlayers()
        local maxPlayers = Players.MaxPlayers or 0

        local uptimeStr = string.format("%02d:%02d:%02d", hours, mins, secs)

        -- Atualizar servidor
        pcall(function()
            servidorParagraph:SetDesc(
                "üéÆ Jogo: " .. placeName ..
                "\nüÜî Job ID: " .. serverId ..
                "\nüåç Regi√£o: " .. region ..
                "\nüì∂ Ping: " .. ping .. " ms" ..
                "\nüñ• FPS: " .. fps ..
                "\n‚è± Tempo de Uso: " .. uptimeStr ..
                "\nüë• Jogadores: " .. playerCount .. "/" .. maxPlayers
            )
        end)

        -- Atualizar jogador
        pcall(function()
            jogadorParagraph:SetDesc(
                "üßë Nome: " .. player.Name ..
                "\nüè∑ Apelido: " .. player.DisplayName ..
                "\nüÜî UserId: " .. player.UserId ..
                "\n‚ö° Executor: " .. executor ..
                "\nüìÖ Account Age: " .. player.AccountAge .. " dias"
            )
        end)
    end
end)

--// ESP System (EcoHub Vision) //--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local WallESP = {}
WallESP.EnabledChams = false
WallESP.EnabledTracers = false
WallESP.EnabledSkeleton = false
WallESP.ChamsColor = Color3.fromRGB(255, 0, 0)
WallESP.TracerColor = Color3.fromRGB(255, 255, 255)
WallESP.SkeletonColor = Color3.fromRGB(0, 255, 0)
WallESP.TracerThickness = 1
WallESP.MaxDistance = 1000
WallESP.Cache = {}
WallESP.RenderConnection = nil

--// Safe Drawing Creation
local function safeNewDrawing(t)
    local ok, obj = pcall(function() return Drawing.new(t) end)
    if ok then return obj end
    return nil
end

--// Create Player Entry
local function createForPlayer(player)
    if WallESP.Cache[player] then return end
    local entry = {
        highlight = nil,
        tracer = nil,
        skeleton = {},
        alive = true
    }

    --// Chams
    pcall(function()
        local highlight = Instance.new("Highlight")
        highlight.Name = "EcoHub_Chams"
        highlight.Parent = player.Character or nil
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.FillColor = WallESP.ChamsColor
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 1
        highlight.Enabled = false
        entry.highlight = highlight
    end)

    --// Tracer
    entry.tracer = safeNewDrawing("Line")
    if entry.tracer then
        entry.tracer.Visible = false
        entry.tracer.Thickness = WallESP.TracerThickness
        entry.tracer.Transparency = 1
        entry.tracer.Color = WallESP.TracerColor
    end

    WallESP.Cache[player] = entry
end

--// Destroy Player Entry
local function destroyForPlayer(player)
    local entry = WallESP.Cache[player]
    if not entry then return end

    pcall(function()
        if entry.highlight then entry.highlight:Destroy() end
    end)
    pcall(function()
        if entry.tracer then entry.tracer.Visible = false entry.tracer:Remove() end
    end)
    pcall(function()
        for _, line in pairs(entry.skeleton) do
            if line then line.Visible = false line:Remove() end
        end
    end)
    WallESP.Cache[player] = nil
end

--// Ensure Skeleton Lines Exist
local function ensureSkeletonLines(entry, count)
    while #entry.skeleton < count do
        local l = safeNewDrawing("Line")
        if l then
            l.Thickness = 1
            l.Transparency = 1
            l.Visible = false
            l.Color = WallESP.SkeletonColor
            table.insert(entry.skeleton, l)
        else
            break
        end
    end
end

--// Skeleton Body Parts
local function getPartsForSkeleton(character)
    local parts = {}
    if not character then return parts end
    local function g(n) return character:FindFirstChild(n) end

    parts.Head = g("Head") or g("head")
    parts.UpperTorso = g("UpperTorso") or g("Torso")
    parts.LowerTorso = g("LowerTorso") or g("HumanoidRootPart")
    parts.LeftUpperArm = g("LeftUpperArm") or g("Left Arm")
    parts.LeftLowerArm = g("LeftLowerArm") or g("LeftForeArm")
    parts.RightUpperArm = g("RightUpperArm") or g("Right Arm")
    parts.RightLowerArm = g("RightLowerArm") or g("RightForeArm")
    parts.LeftUpperLeg = g("LeftUpperLeg") or g("Left Leg")
    parts.LeftLowerLeg = g("LeftLowerLeg") or g("LeftLowerLeg")
    parts.RightUpperLeg = g("RightUpperLeg") or g("Right Leg")
    parts.RightLowerLeg = g("RightLowerLeg") or g("RightLowerLeg")

    return parts
end

--// Update Each Player Entry
local function updateEntry(player, entry)
    local char = player.Character
    if not char or not char.Parent then
        destroyForPlayer(player)
        return
    end

    local humanoid = char:FindFirstChildWhichIsA("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        if entry.highlight then entry.highlight.Enabled = false end
        if entry.tracer then entry.tracer.Visible = false end
        for _, l in pairs(entry.skeleton) do if l then l.Visible = false end end
        return
    end

    local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char.PrimaryPart
    if not root then return end

    local dist = (root.Position - (Camera.CFrame.Position)).Magnitude
    if WallESP.MaxDistance > 0 and dist > WallESP.MaxDistance then
        if entry.highlight then entry.highlight.Enabled = false end
        if entry.tracer then entry.tracer.Visible = false end
        for _, l in pairs(entry.skeleton) do if l then l.Visible = false end end
        return
    end

    --// Chams Update
    if entry.highlight then
        entry.highlight.Parent = char
        entry.highlight.FillColor = WallESP.ChamsColor
        entry.highlight.FillTransparency = 0.7
        entry.highlight.Enabled = WallESP.EnabledChams
    end

    --// Tracer Update
    local head = char:FindFirstChild("Head")
    local headPos = head and head.Position or root.Position
    if entry.tracer then
        entry.tracer.Color = WallESP.TracerColor
        entry.tracer.Thickness = WallESP.TracerThickness
        if WallESP.EnabledTracers then
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
            if onScreen and screenPos.Z > 0 then
                local start = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                entry.tracer.From = start
                entry.tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                entry.tracer.Visible = true
            else
                entry.tracer.Visible = false
            end
        else
            entry.tracer.Visible = false
        end
    end

    --// Skeleton Update
    if WallESP.EnabledSkeleton then
        local parts = getPartsForSkeleton(char)
        local skeletonPairs = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"}
        }
        ensureSkeletonLines(entry, #skeletonPairs)
        for i, pair in ipairs(skeletonPairs) do
            local a, b = parts[pair[1]], parts[pair[2]]
            local line = entry.skeleton[i]
            if a and b and line then
                local sa, onA = Camera:WorldToViewportPoint(a.Position)
                local sb, onB = Camera:WorldToViewportPoint(b.Position)
                if onA and onB and sa.Z > 0 and sb.Z > 0 then
                    line.From = Vector2.new(sa.X, sa.Y)
                    line.To = Vector2.new(sb.X, sb.Y)
                    line.Color = WallESP.SkeletonColor
                    line.Visible = true
                else
                    line.Visible = false
                end
            else
                if line then line.Visible = false end
            end
        end
    else
        for _, l in pairs(entry.skeleton) do if l then l.Visible = false end end
    end
end

--// Update All
local function updateAll()
    for player, _ in pairs(WallESP.Cache) do
        pcall(updateEntry, player, WallESP.Cache[player])
    end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if not WallESP.Cache[player] then
                local char = player.Character
                if char and char.Parent then
                    createForPlayer(player)
                end
            end
        end
    end
end

--// Start Render Loop
local function startRender()
    if WallESP.RenderConnection then return end
    WallESP.RenderConnection = RunService.RenderStepped:Connect(function()
        pcall(updateAll)
    end)
end

--// Stop Render Loop
local function stopRender()
    if WallESP.RenderConnection then
        WallESP.RenderConnection:Disconnect()
        WallESP.RenderConnection = nil
    end
    for player, _ in pairs(WallESP.Cache) do
        destroyForPlayer(player)
    end
    WallESP.Cache = {}
end

--// Player Handlers
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function()
        task.wait(0.3)
        if WallESP.EnabledChams or WallESP.EnabledTracers or WallESP.EnabledSkeleton then
            createForPlayer(plr)
        end
    end)
end)

Players.PlayerRemoving:Connect(function(plr)
    destroyForPlayer(plr)
end)

--// UI Integration (Tabs.Vision)
local Tab = Tabs.Vision
Tab:AddSection("Vision ESP System")

Tab:AddToggle("ChamsToggle", {
    Title = "Enable Chams",
    Default = false,
    Callback = function(v)
        WallESP.EnabledChams = v
        if v then
            for _, p in pairs(Players:GetPlayers()) do if p ~= LocalPlayer then createForPlayer(p) end end
            startRender()
        else
            for _, entry in pairs(WallESP.Cache) do if entry.highlight then entry.highlight.Enabled = false end end
        end
    end
})

Tab:AddColorpicker("ChamsColor", {
    Title = "Chams Color",
    Default = WallESP.ChamsColor,
    Callback = function(c)
        WallESP.ChamsColor = c
        for _, entry in pairs(WallESP.Cache) do if entry.highlight then entry.highlight.FillColor = c end end
    end
})

Tab:AddToggle("TracersToggle", {
    Title = "Enable Tracers",
    Default = false,
    Callback = function(v)
        WallESP.EnabledTracers = v
        if v then
            for _, p in pairs(Players:GetPlayers()) do if p ~= LocalPlayer then createForPlayer(p) end end
            startRender()
        else
            for _, entry in pairs(WallESP.Cache) do if entry.tracer then entry.tracer.Visible = false end end
        end
    end
})

Tab:AddColorpicker("TracerColor", {
    Title = "Tracer Color",
    Default = WallESP.TracerColor,
    Callback = function(c)
        WallESP.TracerColor = c
        for _, entry in pairs(WallESP.Cache) do if entry.tracer then entry.tracer.Color = c end end
    end
})

Tab:AddSlider("TracerThickness", {
    Title = "Tracer Thickness",
    Default = WallESP.TracerThickness,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Callback = function(v)
        WallESP.TracerThickness = v
        for _, entry in pairs(WallESP.Cache) do if entry.tracer then entry.tracer.Thickness = v end end
    end
})

Tab:AddToggle("SkeletonToggle", {
    Title = "Enable Skeleton",
    Default = false,
    Callback = function(v)
        WallESP.EnabledSkeleton = v
        if v then
            for _, p in pairs(Players:GetPlayers()) do if p ~= LocalPlayer then createForPlayer(p) end end
            startRender()
        else
            for _, entry in pairs(WallESP.Cache) do
                for _, l in pairs(entry.skeleton) do if l then l.Visible = false end end
            end
        end
    end
})

Tab:AddColorpicker("SkeletonColor", {
    Title = "Skeleton Color",
    Default = WallESP.SkeletonColor,
    Callback = function(c)
        WallESP.SkeletonColor = c
        for _, entry in pairs(WallESP.Cache) do
            for _, l in pairs(entry.skeleton) do if l then l.Color = c end end
        end
    end
})

Tab:AddSlider("MaxDistance", {
    Title = "Max Distance",
    Default = WallESP.MaxDistance,
    Min = 100,
    Max = 3000,
    Rounding = 0,
    Callback = function(v)
        WallESP.MaxDistance = v
    end
})

Tab:AddButton({
    Title = "Disable All ESP",
    Description = "Turn off all Vision features",
    Callback = function()
        WallESP.EnabledChams = false
        WallESP.EnabledTracers = false
        WallESP.EnabledSkeleton = false
        stopRender()
    end
})

--Teleporte
Tabs.Teleporte:AddSection("Totem")

Tabs.Teleporte:AddDropdown("TotemTP", {
    Title = "Teleportar para Totem",
    Values = {"Aurora", "Sundial", "Windset", "Smokescreen", "Tempest"}
}):OnChanged(function(value)
    if value then
        pcall(function()
            local hrp = GetHumanoidRootPart()
            if not hrp then return end
            
            local positions = {
                Aurora = CFrame.new(-1811, -137, -3282),
                Sundial = CFrame.new(-1148, 135, -1075),
                Windset = CFrame.new(2849, 178, 2702),
                Smokescreen = CFrame.new(2789, 140, -625),
                Tempest = CFrame.new(35, 133, 1943)
            }
            
            if positions[value] then
                hrp.CFrame = positions[value]
                ShowNotification(Lang.notifications.teleported_to .. " Totem " .. value)
            end
        end)
        Options.TotemTP:SetValue(nil)
    end
end)

-- Vari√°veis
local Workspace = game:GetService("Workspace")
local TpSpotsFolder = Workspace:WaitForChild("zones"):WaitForChild("fishing")
local teleportSpots = {}

-- Fun√ß√£o para pegar HRP
local function GetHumanoidRootPart()
	local player = game:GetService("Players").LocalPlayer
	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		return player.Character.HumanoidRootPart
	end
	return nil
end

-- Fun√ß√£o de notifica√ß√£o (ajuste conforme seu sistema)
local function ShowNotification(msg)
	print("[TP] " .. msg)
end

-- Fun√ß√£o de linguagem (exemplo)
local Lang = {
	notifications = {
		teleported_to = "Teleportado para",
		event_not_found = "evento n√£o encontrado!"
	}
}

-- Registrar locais
for _, v in pairs(TpSpotsFolder:GetChildren()) do
	if not table.find(teleportSpots, v.Name) then
		table.insert(teleportSpots, v.Name)
	end
end

-------------------------------------------------
-- MENU TELEPORTE DE EVENTOS
-------------------------------------------------
Tabs.Teleporte:AddSection("Evento")

Tabs.Teleporte:AddDropdown("EventTP", {
	Title = "Teleportar para Evento Mundial",
	Description = "Escolha um evento para teleportar",
	Values = {
		"Redemoinho Estranho",
		"Grande Tubar√£o Martelo",
		"Grande Tubar√£o Branco",
		"Tubar√£o Baleia",
		"As Profundezas - Serpente"
	},
	Default = nil,
	Callback = function(value)
		if not value then return end
		pcall(function()
			local hrp = GetHumanoidRootPart()
			if not hrp then
				ShowNotification("Personagem n√£o encontrado!")
				return
			end

			local fishingZones = Workspace:WaitForChild("zones"):WaitForChild("fishing")
			local eventMap = {
				["Redemoinho Estranho"] = {name = "Isonade", offset = Vector3.new(25, 135, 25)},
				["Grande Tubar√£o Martelo"] = {name = "Great Hammerhead Shark", offset = Vector3.new(0, 135, 0)},
				["Grande Tubar√£o Branco"] = {name = "Great White Shark", offset = Vector3.new(0, 135, 0)},
				["Tubar√£o Baleia"] = {name = "Whale Shark", offset = Vector3.new(0, 135, 0)},
				["As Profundezas - Serpente"] = {name = "The Depths - Serpent", offset = Vector3.new(0, 50, 0)}
			}

			local eventData = eventMap[value]
			if not eventData then
				ShowNotification("Evento inv√°lido: " .. tostring(value))
				return
			end

			local zone = fishingZones:FindFirstChild(eventData.name)
			if zone and zone:IsA("Part") then
				hrp.CFrame = CFrame.new(zone.Position + eventData.offset)
				ShowNotification(Lang.notifications.teleported_to .. " " .. value)
			else
				ShowNotification(value .. " " .. Lang.notifications.event_not_found)
			end
		end)
	end
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local isTeleporting = false
local selectedPlayer = nil
local selectedIsland = nil
local autoUpdateActive = false

local playerDropdown = nil
local islandDropdown = nil

local function ShowNotification(title, message)
    pcall(function()
        if Fluent then
            Fluent:Notify({
                Title = title,
                Content = message,
                Duration = 2
            })
        end
    end)
end

local function GetHumanoidRootPart()
    local success, result = pcall(function()
        if LocalPlayer.Character then
            return LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        end
    end)
    return success and result or nil
end

local function GetOnlinePlayers()
    local playerList = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name then
            table.insert(playerList, player.Name)
        end
    end
    return #playerList > 0 and playerList or {"Nenhum jogador online"}
end

local function TeleportToPlayer(playerName)
    if isTeleporting or not playerName or playerName == "Nenhum jogador online" then return end
    
    isTeleporting = true
    task.spawn(function()
        pcall(function()
            local targetPlayer = Players:FindFirstChild(playerName)
            if not targetPlayer or not targetPlayer.Character then return end
            
            local myHRP = GetHumanoidRootPart()
            local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            
            if myHRP and targetHRP then
                myHRP.CFrame = targetHRP.CFrame + Vector3.new(5, 0, 5)
                ShowNotification("Teleportado", playerName)
            end
        end)
        task.wait(0.5)
        isTeleporting = false
    end)
end

local function UpdatePlayerList()
    pcall(function()
        local newPlayers = GetOnlinePlayers()
        if playerDropdown then
            playerDropdown:SetValues(newPlayers)
        end
    end)
end

local function GetIslandList()
    local islandList = {}
    pcall(function()
        local world = Workspace:FindFirstChild("world")
        if world then
            local spawns = world:FindFirstChild("spawns")
            if spawns then
                local tpSpots = spawns:FindFirstChild("TpSpots")
                if tpSpots then
                    for _, spot in pairs(tpSpots:GetChildren()) do
                        if spot and spot.Name then
                            table.insert(islandList, {
                                Name = spot.Name,
                                CFrame = spot.CFrame
                            })
                        end
                    end
                end
            end
        end
    end)
    return #islandList > 0 and islandList or {{Name = "Nenhuma ilha", CFrame = nil}}
end

local function TeleportToIsland(islandData)
    if isTeleporting or not islandData or not islandData.CFrame then return end
    
    isTeleporting = true
    task.spawn(function()
        pcall(function()
            local hrp = GetHumanoidRootPart()
            if hrp then
                hrp.CFrame = islandData.CFrame + Vector3.new(0, 5, 0)
                ShowNotification("Teleportado", islandData.Name)
            end
        end)
        task.wait(0.5)
        isTeleporting = false
    end)
end

if Tabs and Tabs.Teleporte then
    
    Tabs.Teleporte:AddSection("Teleportar para Jogador")
    
    playerDropdown = Tabs.Teleporte:AddDropdown("PlayerTPDropdown", {
        Title = "Selecionar Jogador",
        Description = "Escolha um jogador online",
        Values = GetOnlinePlayers(),
        Default = 1
    }):OnChanged(function(value)
        if value and value ~= "Nenhum jogador online" then
            selectedPlayer = value
        end
    end)
    
    Tabs.Teleporte:AddButton({
        Title = "Teleportar para Jogador",
        Description = "Teleporta para o jogador selecionado",
        Callback = function()
            if selectedPlayer then
                TeleportToPlayer(selectedPlayer)
            else
                ShowNotification("Erro", "Selecione um jogador")
            end
        end
    })
    
    Tabs.Teleporte:AddButton({
        Title = "Atualizar Lista",
        Description = "Atualiza jogadores online",
        Callback = function()
            UpdatePlayerList()
            local count = 0
            for _ in pairs(Players:GetPlayers()) do
                count = count + 1
            end
            ShowNotification("Atualizado", (count - 1) .. " jogador(es)")
        end
    })
    
    Tabs.Teleporte:AddToggle("AutoUpdatePlayers", {
        Title = "Auto Atualizar",
        Description = "Atualiza lista a cada 5 segundos",
        Default = false
    }):OnChanged(function(value)
        autoUpdateActive = value
        if value then
            task.spawn(function()
                while autoUpdateActive do
                    UpdatePlayerList()
                    task.wait(5)
                end
            end)
        end
    end)
    
    Tabs.Teleporte:AddSection("Teleportar para Ilha")
    
    local islandsList = GetIslandList()
    local islandNames = {}
    local islandsData = {}
    
    for _, island in ipairs(islandsList) do
        table.insert(islandNames, island.Name)
        islandsData[island.Name] = island
    end
    
    if islandNames[1] ~= "Nenhuma ilha" then
        islandDropdown = Tabs.Teleporte:AddDropdown("IslandTP", {
            Title = "Selecionar Ilha",
            Description = "Escolha uma ilha",
            Values = islandNames,
            Default = 1
        }):OnChanged(function(value)
            if value and value ~= "Nenhuma ilha" then
                selectedIsland = value
            end
        end)
        
        Tabs.Teleporte:AddButton({
            Title = "Teleportar para Ilha",
            Description = "Teleporta para a ilha selecionada",
            Callback = function()
                if selectedIsland and islandsData[selectedIsland] then
                    TeleportToIsland(islandsData[selectedIsland])
                else
                    ShowNotification("Erro", "Selecione uma ilha")
                end
            end
        })
        
        Tabs.Teleporte:AddButton({
            Title = "Atualizar Ilhas",
            Description = "Recarrega ilhas disponiveis",
            Callback = function()
                local newIslands = GetIslandList()
                local newNames = {}
                islandsData = {}
                
                for _, island in ipairs(newIslands) do
                    table.insert(newNames, island.Name)
                    islandsData[island.Name] = island
                end
                
                if islandDropdown then
                    islandDropdown:SetValues(newNames)
                end
                
                ShowNotification("Atualizado", #newNames .. " ilha(s)")
            end
        })
    end
    
    Tabs.Teleporte:AddSection("Utilidades")
    
    Tabs.Teleporte:AddButton({
        Title = "Teleportar Mercador",
        Description = "Barco do mercador viajante",
        Callback = function()
            if isTeleporting then return end
            isTeleporting = true
            
            task.spawn(function()
                pcall(function()
                    local hrp = GetHumanoidRootPart()
                    if not hrp then return end
                    
                    local merchant = Workspace.active:FindFirstChild("Merchant Boat")
                    if merchant and merchant:FindFirstChild("Boat") then
                        hrp.CFrame = CFrame.new(merchant.Boat.Position + Vector3.new(0, 10, 0))
                        ShowNotification("Teleportado", "Mercador")
                    else
                        ShowNotification("Erro", "Mercador nao encontrado")
                    end
                end)
                task.wait(0.5)
                isTeleporting = false
            end)
        end
    })
    
    Tabs.Teleporte:AddButton({
        Title = "Criar Zona Segura",
        Description = "Plataforma flutuante no ceu",
        Callback = function()
            task.spawn(function()
                pcall(function()
                    local hrp = GetHumanoidRootPart()
                    if not hrp then return end
                    
                    local safezone = Instance.new("Part")
                    safezone.Size = Vector3.new(30, 1, 30)
                    safezone.Position = Vector3.new(
                        math.random(-2000, 2000),
                        math.random(50000, 90000),
                        math.random(-2000, 2000)
                    )
                    safezone.Anchored = true
                    safezone.BrickColor = BrickColor.new("Lime green")
                    safezone.Material = Enum.Material.ForceField
                    safezone.CanCollide = true
                    safezone.Parent = Workspace
                    
                    task.wait(0.1)
                    hrp.CFrame = safezone.CFrame + Vector3.new(0, 5, 0)
                    ShowNotification("Zona Segura", "Criada")
                end)
            end)
        end
    })
    
end

Players.PlayerAdded:Connect(function()
    task.wait(0.5)
    UpdatePlayerList()
end)

Players.PlayerRemoving:Connect(function()
    task.wait(0.5)
    UpdatePlayerList()
end)

--Lojinha
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local autoSellEnabled = false
local sellDelay = 1

local function ShowNotification(title, message)
    pcall(function()
        if Fluent then
            Fluent:Notify({
                Title = title,
                Content = message,
                Duration = 3
            })
        end
    end)
end

local function SellHand()
    pcall(function()
        local character = LocalPlayer.Character
        if not character then return end
        
        local tool = character:FindFirstChildOfClass("Tool")
        if not tool then return end
        
        local events = ReplicatedStorage:FindFirstChild("events")
        if not events then return end
        
        local sellEvent = events:FindFirstChild("SellHand")
        if not sellEvent then return end
        
        sellEvent:InvokeServer(tool)
        task.wait(0.2)
    end)
end

local function SellAll()
    pcall(function()
        local character = LocalPlayer.Character
        if not character then return end
        
        local events = ReplicatedStorage:FindFirstChild("events")
        if not events then return end
        
        local sellEvent = events:FindFirstChild("SellAll")
        if not sellEvent then return end
        
        sellEvent:InvokeServer()
        task.wait(0.3)
    end)
end

local function AutoSellLoop()
    while autoSellEnabled do
        task.wait(sellDelay)
        if autoSellEnabled then
            SellAll()
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
end)

task.delay(1, function()
    if Tabs and Tabs.Lojinha then
        
        Tabs.Lojinha:AddSection("Sistema de Venda Manual")
        
        Tabs.Lojinha:AddButton({
            Title = "Vender Peixe da Mao",
            Description = "Vende o peixe que esta na sua mao",
            Callback = function()
                SellHand()
                ShowNotification("Vendido", "Peixe da mao vendido!")
            end
        })
        
        Tabs.Lojinha:AddButton({
            Title = "Vender Tudo Agora",
            Description = "Vende todos os peixes do inventario",
            Callback = function()
                SellAll()
                ShowNotification("Vendido", "Inventario vendido!")
            end
        })
        
        Tabs.Lojinha:AddSection("Auto Vender")
        
        Tabs.Lojinha:AddToggle("AutoSellToggle", {
            Title = "Auto Vender Peixes",
            Description = "Vende automaticamente sem notificacoes",
            Default = false
        }):OnChanged(function(value)
            autoSellEnabled = value
            if value then
                ShowNotification("Auto Vender", "Ativado!")
                task.spawn(AutoSellLoop)
            else
                ShowNotification("Auto Vender", "Desativado!")
            end
        end)
        
        Tabs.Lojinha:AddSlider("AutoSellDelaySlider", {
            Title = "Intervalo de Venda",
            Description = "Tempo em segundos entre vendas",
            Min = 0.5,
            Max = 10,
            Default = 1,
            Rounding = 0.5
        }):OnChanged(function(value)
            sellDelay = value
        end)
        
    end
end)

--Local Player
--Local Player
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Character, Humanoid, RootPart

local function refreshCharacter()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    Humanoid = Character:WaitForChild("Humanoid", 5)
    RootPart = Character:WaitForChild("HumanoidRootPart", 5)
end

refreshCharacter()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.3)
    refreshCharacter()
end)

local Movement = {
    SpeedEnabled = false,
    SpeedValue = 20,
    InfiniteJumpEnabled = false,
    AutoJumpEnabled = false,
    NoclipEnabled = false,
    FlyEnabled = false,
    FlySpeed = 50
}

local connections = {
    noclip = nil,
    fly = nil
}

local function StartNoclip()
    if connections.noclip then
        connections.noclip:Disconnect()
    end
    
    connections.noclip = RunService.Stepped:Connect(function()
        if Movement.NoclipEnabled and Character then
            for _, part in pairs(Character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function StopNoclip()
    if connections.noclip then
        connections.noclip:Disconnect()
        connections.noclip = nil
    end
    
    if Character then
        for _, part in pairs(Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

local function StartFly()
    if connections.fly then
        connections.fly:Disconnect()
    end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = RootPart
    
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 9e9
    bodyGyro.Parent = RootPart
    
    connections.fly = RunService.Heartbeat:Connect(function()
        if not Movement.FlyEnabled or not RootPart then
            if bodyVelocity then bodyVelocity:Destroy() end
            if bodyGyro then bodyGyro:Destroy() end
            if connections.fly then
                connections.fly:Disconnect()
                connections.fly = nil
            end
            return
        end
        
        local camera = workspace.CurrentCamera
        local moveDirection = Vector3.new(0, 0, 0)
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveDirection = moveDirection + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveDirection = moveDirection - Vector3.new(0, 1, 0)
        end
        
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
        end
        
        bodyVelocity.Velocity = moveDirection * Movement.FlySpeed
        bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        bodyGyro.CFrame = camera.CFrame
    end)
end

local function StopFly()
    if connections.fly then
        connections.fly:Disconnect()
        connections.fly = nil
    end
    
    if RootPart then
        for _, obj in pairs(RootPart:GetChildren()) do
            if obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") then
                obj:Destroy()
            end
        end
    end
end

RunService.Stepped:Connect(function()
    if Movement.SpeedEnabled and Humanoid and Humanoid.Parent then
        if Humanoid.MoveDirection.Magnitude > 0 then
            Humanoid:Move(Humanoid.MoveDirection, true)
            Humanoid.WalkSpeed = Movement.SpeedValue
        else
            Humanoid.WalkSpeed = Movement.SpeedValue
        end
    else
        if Humanoid and Humanoid.WalkSpeed ~= 16 then
            Humanoid.WalkSpeed = 16
        end
    end
end)

UserInputService.JumpRequest:Connect(function()
    if Movement.InfiniteJumpEnabled and Humanoid then
        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

RunService.Heartbeat:Connect(function()
    if Movement.AutoJumpEnabled and Humanoid then
        if Humanoid.FloorMaterial ~= Enum.Material.Air then
            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

if Tabs and Tabs.Usuario then
    
    Tabs.Usuario:AddSection("Movimento")
    
    Tabs.Usuario:AddToggle("SpeedToggle", {
        Title = "Velocidade",
        Description = "Aumenta sua velocidade de caminhada",
        Default = false
    }):OnChanged(function(value)
        Movement.SpeedEnabled = value
        if value and Humanoid then
            Humanoid.WalkSpeed = Movement.SpeedValue
        else
            if Humanoid then 
                Humanoid.WalkSpeed = 16 
            end
        end
    end)
    
    Tabs.Usuario:AddSlider("SpeedValue", {
        Title = "Valor da Velocidade",
        Description = "Define a velocidade (16-200)",
        Default = 20,
        Min = 16,
        Max = 200,
        Rounding = 1
    }):OnChanged(function(value)
        Movement.SpeedValue = value
        if Movement.SpeedEnabled and Humanoid then
            Humanoid.WalkSpeed = value
        end
    end)
    
    Tabs.Usuario:AddSection("Habilidades Especiais")
    
    Tabs.Usuario:AddToggle("FlyToggle", {
        Title = "Fly",
        Description = "Voa livremente pelo mapa",
        Default = false
    }):OnChanged(function(value)
        Movement.FlyEnabled = value
        if value then
            StartFly()
        else
            StopFly()
        end
    end)
    
    Tabs.Usuario:AddSlider("FlySpeed", {
        Title = "Velocidade do Fly",
        Description = "Define a velocidade do voo (10-200)",
        Default = 50,
        Min = 10,
        Max = 2000,
        Rounding = 1
    }):OnChanged(function(value)
        Movement.FlySpeed = value
    end)
    
    Tabs.Usuario:AddToggle("NoclipToggle", {
        Title = "Noclip",
        Description = "Atravessa paredes e objetos",
        Default = false
    }):OnChanged(function(value)
        Movement.NoclipEnabled = value
        if value then
            StartNoclip()
        else
            StopNoclip()
        end
    end)
    
    Tabs.Usuario:AddSection("Pulo")
    
    Tabs.Usuario:AddToggle("InfiniteJump", {
        Title = "Pulo Infinito",
        Description = "Pula infinitamente no ar",
        Default = false
    }):OnChanged(function(value)
        Movement.InfiniteJumpEnabled = value
    end)
    
    Tabs.Usuario:AddToggle("AutoJump", {
        Title = "Auto Pulo",
        Description = "Pula automaticamente ao tocar o chao",
        Default = false
    }):OnChanged(function(value)
        Movement.AutoJumpEnabled = value
    end)
    
    Tabs.Usuario:AddSection("Controles")
    
    Tabs.Usuario:AddParagraph({
        Title = "Como Usar Fly",
        Content = "W/A/S/D: Mover\nSpace: Subir\nShift: Descer"
    })
    
    Tabs.Usuario:AddButton({
        Title = "Desativar Tudo",
        Description = "Desativa todas as funcionalidades",
        Callback = function()
            Movement.SpeedEnabled = false
            Movement.InfiniteJumpEnabled = false
            Movement.AutoJumpEnabled = false
            Movement.NoclipEnabled = false
            Movement.FlyEnabled = false
            StopNoclip()
            StopFly()
            if Humanoid then
                Humanoid.WalkSpeed = 16
            end
        end
    })
    
end

--Auto-Farme
Tabs.Farm:AddSection("Fontes de Peixes")

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Vari√°veis de controle
local billboardsData = {}
local selectedSource = nil
local isTeleporting = false
local isUpdating = false

-- Fun√ß√£o para obter HumanoidRootPart
local function GetHumanoidRootPart()
    local success, result = pcall(function()
        if LocalPlayer and LocalPlayer.Character then
            return LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        end
        return nil
    end)
    
    return success and result or nil
end

-- Fun√ß√£o para listar BillboardGuis
local function listarBillboards()
    local billboards = {}
    local nomes = {}
    
    pcall(function()
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj and obj:IsA("BillboardGui") and obj.Parent then
                local parentName = tostring(obj.Parent.Name)
                local objName = tostring(obj.Name)
                local nome = parentName .. " (" .. objName .. ")"
                
                if not nomes[nome] then
                    nomes[nome] = true
                    table.insert(billboards, {
                        Nome = nome,
                        Objeto = obj
                    })
                end
            end
        end
    end)
    
    -- Ordena alfabeticamente
    table.sort(billboards, function(a, b)
        return a.Nome < b.Nome
    end)
    
    return billboards
end

-- Fun√ß√£o para teleportar
local function teleportarParaFonte(selecionado)
    if isTeleporting then
        return
    end
    
    isTeleporting = true
    
    task.spawn(function()
        local success = pcall(function()
            if not selecionado or not selecionado.Parent then
                error("Fonte inv√°lida")
            end
            
            local hrp = GetHumanoidRootPart()
            if not hrp then
                error("HumanoidRootPart n√£o encontrado")
            end
            
            local root = selecionado.Parent:FindFirstChild("HumanoidRootPart") 
                      or selecionado.Parent:FindFirstChild("PrimaryPart") 
                      or selecionado.Parent
            
            if root then
                if root:IsA("BasePart") then
                    hrp.CFrame = root.CFrame + Vector3.new(0, 3, 0)
                elseif root:IsA("Model") then
                    hrp.CFrame = root:GetPivot() * CFrame.new(0, 3, 0)
                end
            end
        end)
        
        task.wait(0.5)
        isTeleporting = false
    end)
end

-- Carrega lista inicial
local billboards = listarBillboards()
local valores = {}

for _, v in ipairs(billboards) do
    table.insert(valores, v.Nome)
    billboardsData[v.Nome] = v.Objeto
end

if #valores == 0 then
    valores = {"Nenhuma fonte encontrada"}
end

-- Cria o dropdown (sempre vis√≠vel)
local DropdownFontes = Tabs.Farm:AddDropdown("FontesPeixes", {
    Title = "Fontes de Peixes",
    Description = "Selecione uma fonte para teleportar",
    Values = valores,
    Multi = false,
    Default = 1,
    Callback = function(value)
        if value and value ~= "Nenhuma fonte encontrada" then
            selectedSource = value
            local selecionado = billboardsData[value]
            if selecionado then
                teleportarParaFonte(selecionado)
            end
        end
    end
})

-- Bot√£o de atualizar lista
Tabs.Farm:AddButton({
    Title = "Atualizar Lista",
    Description = "Atualiza todas as fontes de peixes detectadas",
    Callback = function()
        if isUpdating then
            Fluent:Notify({
                Title = "Aguarde",
                Content = "Atualiza√ß√£o em andamento",
                Duration = 1.5
            })
            return
        end
        
        isUpdating = true
        
        task.spawn(function()
            pcall(function()
                task.wait(0.1)
                
                local newBillboards = listarBillboards()
                local newValores = {}
                
                -- Limpa dados antigos
                billboardsData = {}
                
                for _, v in ipairs(newBillboards) do
                    table.insert(newValores, v.Nome)
                    billboardsData[v.Nome] = v.Objeto
                end
                
                if #newValores == 0 then
                    newValores = {"Nenhuma fonte encontrada"}
                end
                
                -- Atualiza o dropdown usando Options
                if Options and Options.FontesPeixes then
                    Options.FontesPeixes:SetValue(newValores[1])
                    Options.FontesPeixes.Values = newValores
                    Options.FontesPeixes:BuildDropdownList()
                    Options.FontesPeixes:Display()
                end
                
                local count = #newValores == 1 and newValores[1] == "Nenhuma fonte encontrada" and 0 or #newValores
                Fluent:Notify({
                    Title = "Lista Atualizada",
                    Content = count .. " fonte(s) encontrada(s)",
                    Duration = 2
                })
            end)
            
            task.wait(0.3)
            isUpdating = false
        end)
    end
})

-- Limpeza ao sair
game.Players.LocalPlayer.AncestryChanged:Connect(function()
    isTeleporting = false
    isUpdating = false
    billboardsData = {}
    selectedSource = nil
end)

--Auto Farme
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")

local LocalPlayer = Players.LocalPlayer
local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local autoCastEnabled = false
local autoShakeEnabled = false
local autoReelEnabled = false
local FreezeChar = false

local CastMode = "Legit"
local ShakeMode = "Navigation"
local ReelMode = "Blatant"

local isCasting = false
local isShaking = false
local isPowerCharging = false
local lastShakeAttempt = 0

local connections = {
    freeze = nil,
    antiKick = nil,
    microMove = nil
}

local function GetHumanoidRootPart()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        return char.HumanoidRootPart
    end
    return nil
end

LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

connections.antiKick = task.spawn(function()
    while task.wait(120) do
        pcall(function()
            VirtualUser:CaptureController()
            VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
            task.wait(0.1)
            VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        end)
    end
end)

connections.microMove = task.spawn(function()
    while task.wait(300) do
        pcall(function()
            if LocalPlayer and LocalPlayer.Character then
                local hrp = GetHumanoidRootPart()
                if hrp then
                    local oldCF = hrp.CFrame
                    hrp.CFrame = oldCF * CFrame.new(0, 0.01, 0)
                    task.wait(0.1)
                    hrp.CFrame = oldCF
                end
            end
        end)
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    LocalCharacter = char
    task.wait(1)
    if autoCastEnabled then
        pcall(function()
            local RodName = ReplicatedStorage.playerstats[LocalPlayer.Name].Stats.rod.Value
            if LocalPlayer.Backpack:FindFirstChild(RodName) then
                char.Humanoid:EquipTool(LocalPlayer.Backpack[RodName])
            end
        end)
    end
end)

local function TryEquipRod()
    local success, rodName = pcall(function()
        return ReplicatedStorage.playerstats[LocalPlayer.Name].Stats.rod.Value
    end)
    if not success or not rodName then return nil end
    
    local rod = LocalPlayer.Backpack:FindFirstChild(rodName) or LocalCharacter:FindFirstChild(rodName)
    if rod and LocalCharacter and LocalCharacter:FindFirstChild("Humanoid") then
        pcall(function() 
            LocalCharacter.Humanoid:EquipTool(rod) 
        end)
        task.wait(0.03)
        return LocalCharacter:FindFirstChildOfClass("Tool")
    end
    return nil
end

local function autoCast()
    if not LocalCharacter then return end
    
    local tool = LocalCharacter:FindFirstChildOfClass("Tool")
    if not tool then return end
    
    local hasBobber = tool:FindFirstChild("bobber")
    if hasBobber then return end
    
    if CastMode == "Legit" then
        local hrp = GetHumanoidRootPart()
        if not hrp then return end
        
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, LocalPlayer, 0)
        
        local connection
        connection = hrp.ChildAdded:Connect(function(child)
            if child.Name == "power" then
                local powerbar = child:WaitForChild("powerbar", 1)
                if powerbar then
                    local bar = powerbar:WaitForChild("bar", 1)
                    if bar then
                        local sizeConnection
                        sizeConnection = bar:GetPropertyChangedSignal("Size"):Connect(function()
                            if bar.Size == UDim2.new(1, 0, 1, 0) then
                                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, LocalPlayer, 0)
                                if sizeConnection then sizeConnection:Disconnect() end
                                if connection then connection:Disconnect() end
                            end
                        end)
                    end
                end
            end
        end)
        
        task.delay(3, function()
            if connection then connection:Disconnect() end
        end)
    elseif CastMode == "Blatant" then
        local rod = LocalCharacter:FindFirstChildOfClass("Tool")
        if rod and rod:FindFirstChild("values") and string.find(rod.Name, "Rod") then
            task.wait(0.5)
            local Random = math.random(90, 99)
            rod.events.cast:FireServer(Random)
        end
    end
    
    task.wait(0.5)
end

task.spawn(function()
    while task.wait(0.3) do
        if autoCastEnabled and not isCasting and not isPowerCharging then
            pcall(function()
                local tool = LocalCharacter and LocalCharacter:FindFirstChildOfClass("Tool")
                local hasBobber = tool and tool:FindFirstChild("bobber")
                local reelUI = PlayerGui:FindFirstChild("reel")
                local shakeUI = PlayerGui:FindFirstChild("shakeui")
                
                if not hasBobber and not reelUI and not shakeUI then
                    if LocalPlayer and LocalPlayer.Parent then
                        autoCast()
                    end
                end
            end)
        end
    end
end)

local function autoShake()
    if isShaking or isPowerCharging or not autoShakeEnabled then return end
    
    local currentTime = tick()
    if currentTime - lastShakeAttempt < 0.1 then return end
    
    local shakeui = PlayerGui:FindFirstChild("shakeui")
    if not shakeui then return end
    
    local safezone = shakeui:FindFirstChild("safezone")
    if not safezone then return end
    
    local button = safezone:FindFirstChild("button") or safezone:FindFirstChildOfClass("ImageButton")
    if not button or not button.Visible then return end

    isShaking = true
    lastShakeAttempt = currentTime

    task.spawn(function()
        pcall(function()
            if ShakeMode == "Navigation" then
                GuiService.SelectedObject = button
                task.wait(0.01)
                if GuiService.SelectedObject == button then
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.01)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                end
                task.wait(0.01)
                GuiService.SelectedObject = nil
            else
                local pos = button.AbsolutePosition
                local size = button.AbsoluteSize
                local cx = pos.X + size.X / 2
                local cy = pos.Y + size.Y / 2
                VirtualInputManager:SendMouseButtonEvent(cx, cy, 0, true, LocalPlayer, 0)
                task.wait(0.01)
                VirtualInputManager:SendMouseButtonEvent(cx, cy, 0, false, LocalPlayer, 0)
            end
        end)
        
        task.wait(0.05)
        isShaking = false
    end)
end

local function autoReel()
    if not autoReelEnabled then return end
    
    local reel = PlayerGui:FindFirstChild("reel")
    if not reel then return end
    
    local bar = reel:FindFirstChild("bar")
    if not bar then return end
    
    local playerbar = bar:FindFirstChild("playerbar")
    local fish = bar:FindFirstChild("fish")
    if not playerbar or not fish then return end
    
    pcall(function()
        if ReelMode == "Blatant" then
            playerbar.Position = fish.Position
        else
            local playerPos = playerbar.Position.X.Offset
            local fishPos = fish.Position.X.Offset
            local distance = fishPos - playerPos
            
            if math.abs(distance) > 1 then
                local direction = distance > 0 and 1 or -1
                local newPos = playerPos + (200 * direction * 0.016)
                playerbar.Position = UDim2.new(
                    playerbar.Position.X.Scale, 
                    newPos, 
                    playerbar.Position.Y.Scale, 
                    playerbar.Position.Y.Offset
                )
            else
                playerbar.Position = fish.Position
            end
        end
    end)
end

RunService.Heartbeat:Connect(function()
    pcall(function()
        if autoShakeEnabled then autoShake() end
        if autoReelEnabled then autoReel() end
    end)
end)

PlayerGui.DescendantAdded:Connect(function(desc)
    task.wait(0.02)
    if desc.Name == "button" and desc.Parent and desc.Parent.Name == "safezone" then
        if autoShakeEnabled and not isPowerCharging and not isShaking then
            task.wait(0.03)
            pcall(autoShake)
        end
    end
end)

PlayerGui.DescendantRemoving:Connect(function(desc)
    if desc.Name == "playerbar" and desc.Parent and desc.Parent.Name == "bar" then
        task.spawn(function()
            task.wait(0.3)
            if autoCastEnabled and not PlayerGui:FindFirstChild("reel") and not PlayerGui:FindFirstChild("shakeui") then
                pcall(autoCast)
            end
        end)
    end
    
    if desc.Name == "button" and desc.Parent and desc.Parent.Name == "safezone" then
        isShaking = false
    end
end)

if Tabs and Tabs.Farm then
    Tabs.Farm:AddParagraph({
        Title = "Automacao Principal",
        Content = "Sistema AFK ativo automaticamente"
    })
    Tabs.Farm:AddSection("Farm")
    Tabs.Farm:AddToggle("AutoCastToggle", {
        Title = "Auto Lancar",
        Description = "Lanca a vara automaticamente",
        Default = false,
        Callback = function(value)
            pcall(function()
                autoCastEnabled = value
                if value then
                    local RodName = ReplicatedStorage.playerstats[LocalPlayer.Name].Stats.rod.Value
                    if LocalPlayer.Backpack:FindFirstChild(RodName) then
                        LocalCharacter.Humanoid:EquipTool(LocalPlayer.Backpack[RodName])
                    end
                    task.wait(0.05)
                    if not isCasting then autoCast() end
                else
                    isCasting = false
                    isPowerCharging = false
                end
            end)
        end
    })

    Tabs.Farm:AddToggle("AutoShakeToggle", {
        Title = "Auto Agitar",
        Description = "Agita automaticamente no minigame",
        Default = false,
        Callback = function(value)
            autoShakeEnabled = value
            isShaking = false
            lastShakeAttempt = 0
        end
    })

    Tabs.Farm:AddToggle("AutoReelToggle", {
        Title = "Auto Recolher",
        Description = "Recolhe o peixe automaticamente",
        Default = false,
        Callback = function(value)
            autoReelEnabled = value
        end
    })

    Tabs.Farm:AddParagraph({
        Title = "Configuracoes",
        Content = "Ajuste o comportamento do farm"
    })
    Tabs.Farm:AddSection("Op√ß√£o")
    Tabs.Farm:AddDropdown("CastModeDropdown", {
        Title = "Modo de Lancamento",
        Description = "Legit ou Blatant",
        Values = {"Legit", "Blatant"},
        Multi = false,
        Default = 1,
        Callback = function(value)
            if value then CastMode = value end
        end
    })

    Tabs.Farm:AddDropdown("ShakeModeDropdown", {
        Title = "Modo de Agitacao",
        Description = "Navigation ou Mouse",
        Values = {"Navigation", "Mouse"},
        Multi = false,
        Default = 1,
        Callback = function(value)
            if value then ShakeMode = value end
        end
    })

    Tabs.Farm:AddDropdown("ReelModeDropdown", {
        Title = "Modo de Recolhimento",
        Description = "Legit ou Blatant",
        Values = {"Legit", "Blatant"},
        Multi = false,
        Default = 2,
        Callback = function(value)
            if value then ReelMode = value end
        end
    })

    Tabs.Farm:AddParagraph({
        Title = "Utilidades",
        Content = "Opcoes extras de farm"
    })

    Tabs.Farm:AddSection("Modo de Jogo")
    Tabs.Farm:AddToggle("FreezeCharToggle", {
        Title = "Congelar Personagem",
        Description = "Mantem o personagem parado",
        Default = false,
        Callback = function(value)
            FreezeChar = value
            if value then
                local hrp = GetHumanoidRootPart()
                if hrp then
                    local oldpos = hrp.CFrame
                    if connections.freeze then connections.freeze:Disconnect() end
                    connections.freeze = RunService.Stepped:Connect(function()
                        if FreezeChar then
                            local now = GetHumanoidRootPart()
                            if now then now.CFrame = oldpos end
                        end
                    end)
                end
            else
                if connections.freeze then
                    connections.freeze:Disconnect()
                    connections.freeze = nil
                end
            end
        end
    })
end

game.Players.LocalPlayer.AncestryChanged:Connect(function()
    for k, v in pairs(connections) do
        if v and type(v) == "userdata" then
            pcall(function() v:Disconnect() end)
        end
        connections[k] = nil
    end
end)
